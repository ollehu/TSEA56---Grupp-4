\documentclass[11pt]{article}

\usepackage{extras} % Se extras.sty

\begin{document} 
\begin{titlepage}
\begin{center}

{\Large\bfseries TSEA56 - Kandidatprojekt i elektronik \\ LIPS Förstudie: Kommunikation}

\vspace{5em}

Version 0.1

\vspace{5em}
Grupp 4 \\
\begin{tabular}{rl}
Tronje, Elena&\verb+eletr654+
\\
Gustafsson, Lovisa&\verb+lovgu777+
\\
\end{tabular}

\vspace{5em}
\today

\vspace{16em}
Status
\begin{longtable}{|l|l|l|} \hline

Granskad & - & - \\ \hline
Godkänd & - & - \\ \hline
 
\end{longtable}

\end{center}
\end{titlepage}

\pagebreak
\begin{center}

\section*{PROJEKTIDENTITET}
2016/VT, Undsättningsrobot Gr. 4

Linköpings tekniska högskola, ISY
\vspace{5em}
\begin{center}

\begin{tabular}{|l|l|l|l|} \hline
\textbf{Namn} & \textbf{Ansvar} & \textbf{Telefon} & \textbf{E-post}  \\ \hline 
Isak Strömberg (IS) & Projektledare & 073-980 38 50 & isast763@student.liu.se \\ \hline
Olle Hynén Ulfsjöö (OHU)& Dokumentansvarig & 070-072 91 84 & ollul666@student.liu.se \\ \hline
Emil Wasteson (EW) & Hårdvaruansvarig & 076-836 61 66 & emiwa068@student.liu.se \\ \hline
Elena Tronje (ET) & Mjukvaruansvarig & 072-276 92 93 & eletr654@student.liu.se \\ \hline
Zimon Inge (ZI)& Testansvarig & 070-171 35 18 & zimin415@student.liu.se \\ \hline
Lovisa Gustafsson (LG) & Leveransansvarig & 070-210 32 53 & lovgu777@student.liu.se \\ \hline
\end{tabular}

\end{center}

E-postlista för hela gruppen: isast763@student.liu.se

\vspace{5em}
Kund: ISY, Linköpings universitet \\
tel: 013-28 10 00, fax: 013-13 92 82 \\
Kontaktperson hos kund: Mattias Krysander \\
tel: 013-28 21 98, e-post: matkr@isy.liu.se \\

\vspace{5em}
Kursansvarig:  Tomas Svensson\\
tel: 013-28 13 68, e-post: tomass@isy.liu.se \\
Handledare: Peter Johansson \\
tel: 013-28 13 45, e-post: peter.a.johansson@liu.se
\end{center}
\pagebreak

\tableofcontents

\pagebreak
\section*{Dokumenthistorik}
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|} \hline

\textbf{Version} & \textbf{Datum} & \textbf{Utförda förändringar} & \textbf{Utförda av} & \textbf{Granskad} \\ \hline
0.1 & - &  Första utkastet & Grupp 4 & - \\ \hline
\end{tabular}
\end{table}

\pagebreak
\pagenumbering{arabic}

\begin{flushleft}

\section{Inledning}
Vid utveckling av en robot som består av olika moduler med olika funktion är det viktigt att undersöka hur dessa moduler ska integreras på bästa sätt. Därför är det intressant att titta på hur de ska kommunicera med varandra och tillsammans funktionera som en robot och inte som delmoduler. 

%För att undersöka detta genomförs en studie av kommunikationsalternativ mellan moduler och hur modulerna på ett bra sätt byggs upp för att lätt kunna integreras med varandra. 

\subsection{Syfte}
Syftet med denna studie är att undersöka hur intern kommunikation och integration av moduler kan ske vid utveckling av en modulär robot samt analysera vad som skulle var lämpligt för vårt projekt.

%(Syftet med denna studie är att beröra frågor som rör kommunikation och integration vid modulär uppbyggnad av för att i projektfasen ha en grund att stå på.)

\pagebreak

\section{Problemformulering}
\textit{Frågeställningar som rapporten ska behandla}

Rapporten tar avstamp i frågor som berör integration och kommunikation. De generella frågeställningarna är:

\begin{itemize}
	\item Beskriv olika principer för kommunikation mellan processorer. Prestanda, funktion , 
robusthet, etc (SPI, I2C, ...). Vilken/vilka lösningar passar er robot?  
	\item Hur utvecklar och testar man ett realtidssystem som innehåller flera moduler/processorer Integration? Med eller utan operativsystem? Olika programstrukturer? Avbrottsstyrning? C eller assembler? Varför modularisering? Hållbar utveckling? Om ni skulle kommersialisera er robot i 100-tal eller miljontal, hur skulle ni byggt den då? 
\end{itemize}

För att denna förstudie ska få mening i det projekt som den föregår har frågorna smalnats av och formulerats om till följande:

\begin{itemize}
	\item Vilken konfiguration av en I\textsuperscript{2}C-buss är lämplig i ett modulbaserat projekt?
	\item Hur görs integration av moduler på ett smidigt/lättarbetat/bra sätt?
	
		\begin{itemize}
			\item Avbrott eller pollning?
			\item Hur ska gränssnitt designas?
			\item C eller assembler?
			\item Hur ska tester designas för att säkerställa att respektive modul fungerar enligt kravspecifikation?
		\end{itemize}

\end{itemize}

\pagebreak

\section{Kunskapsbas}
\textit{Litteratur, datablad, dokumentation, bakgrundsteori, etc. Dela gärna upp efter vad förstudien handlar om.}

\subsection{I\textsuperscript{2}C}
I\textsuperscript{2}C-bussen är en tvåtrådad buss som sköter överföringen mellan två enhter. Varje enhet har en unik adress, och kan konfigureras till att agera både mottagare och sändare. Utöver detta kan enheter kopplade till samma buss hamna i två olika roller, \textit{slave} eller \textit{master}. De som kan initiera överföringar via bussen är de som innehar rollen \textit{master} kan. På varje buss kan det finnas flera master-enheter, likväl som flera slave-enheter. Hastigheten med vilken data kan skickas är i standardläge 100 kbit/s. Vid High speed-mode kan den komm upp i 3.4 Mbit/s.

Överföringsprocessen består av fem steg: (1) Initiering, (2) adress till slav, (3) datariktning, (4) informationsutbyte och (5) avslut. (2) och (3) är informationen i den första byten. Viktigt att notera är att när en master-enhetet initierat anses alla andra enheter vara slavar. I (4) måste informationen skickas i hela bytes, där den mest signifikanta biten (MSB) skickas först. Antalet bytes som kan skickas per överföring är inte reglerat.

När bussen är ledig ligger båda ledningarna SDA och SCL höga. (1) och (5) triggas av negativ respektive positiv flank på SDA så länge SCL ligger hög. Ett alternativ till att trigga avslut är att trigga en ny start, dvs att master-enheten har fortsatt kommunikation över bussen. Är inte slaven redo för överföring kan den sätta master-enheten i vänteläge.

https://docs.isy.liu.se/twiki/pub/VanHeden/DataSheets/i2cspec2000.pdf

Ci tänker att vi har en avbrottstyrd i2c va? eller en pollad?


\subsection{Lovisa flummar}


Bra grej, "The length of the polling loopmust be short enough to never miss a byte of serial data or byte from any other interface. In an interrupt-driven system, the same considerations apply to length of any polling loop plus the worst-case interrupt latencies."

\subsection{?}
Enligt \cite{GenoM} finns det tre aspekter att ha i åtanke vid uppbyggnad av en robots funktionsnivå: Realtidssystem, kontrollerat system och öppet system. 

\textit{Realtidssystem}- Denna nivå beskriver processerna mellan roboten och dess omgivning genom sensorer exempelvis. Denna nivå behöver kunna utföra alla delar som behöver ske i realtid så som exempelvis kontroll av styrservo och behöver därför kunna utföra synkronisering och kommunicera mellan "uppgifter" för att nämna några saker. 

\textit{Kontrollerat system}- ?

\textit{Öppet system}- Roboten borde vara modifierbar, det ska var lätt att integrera eller ändra olika funktioners utformning efter tilltänkt tillämpning. För att göra detta behövs ett stegvis uppbyggt system med vanlig integrationsmetodologi. 

Alltså behövs en modulärt uppbyggd robot både vad gäller funktionsnivå, standard-uppbyggnad och gränsnitt för modulerna. 

Realtidssystem har ofta "Event- driven  scheduling" vilket innebär att uppgifter adderas och tas bort från listan över uppgifter allt eftersom föutsättningar ändras. 

\subsection{Assembler och C för programmering av mikroprocessorer}

I \cite{RWD} anses Assembler vara ett snabbare alternativ än högnivå språk som C i enklare konstruktioner av realtidssystem. Nackdelen är dock att framtida användare av koden får svårare att läsa den och måste sätta sig in i hur processorn fungerar. Dessutom ju mer komplext projektet blir desto mer tid går till att avsöka koden och att inte behöva lära sig nytt språk för varje processor blir också viktigt. Alltså bli Assembler inte lägre så attraktivt. 

Det finns också möjlighet att kombinera båda språken. I \cite{AssC} beskrivs hur Assembler kan användas i ett C-projekt i Atmel Studio 6. En Assembler rutin kan bli synlig för en C kodad fil och de kan dela globala variabler. Detta kan vara användbart om vissa delar blir enklare eller tydligare att koda i Assembler.

\subsection{Testa system}
En simulator är ett enkelt val för testning av kod då de flesta microprocesorerna har en egen sådan. Simulatorer brister dock i att det är svårt att förutse allt som kommer hända i verkligheten vilket gör att den som programmerar måste vara extremt medveten om alla situationer som kan uppstå annars missas saker. Avbrott försvårar detta.\cite{RWD}

För testning av system föreslår \cite{RWD} att testning av hårdvara och mjukvara sker var för sig för att sen testas tillsammans. Hårdvarutestning kan vara svårt men det kan testas att skriva enklare kod som exempelvis att loopa eller skriva till en viss port och se vad ett oscilloskop ger för utslag. Mjukvarutestning görs bäst genom att dela upp koden och testa en liten bit i taget lämpligtvis med hjälp av breakpoints. Vad gäller test av hårdvara i realtidssystem blir det svårare då avbrott sker kontinuerligt vilket gör att breakpoints i koden inte är optimalt. För att underlätta då kan alla avbrott som inte är superviktiga stängas av för att se om felet kvarstår och sen aktivera ett avbrott i taget för att hitta var felet är. Ta hjälp av en lokiganalysator för att isolera felet i hårdvaran. För att testa både hårdvara och mjukvara föreslås funktionell testplan. Med hjälp av en bra kravspecifikation kan testerna lätt definieras. Viktigt är att inte glömma att test undantagsfall också. 


\pagebreak

\section{Rapportens huvuddel, byt rubriknamn}
\textit{Modeller, beräkningar, analyser och ev experiment. Dela gärna upp efter vad förstudien handlar om.}

\subsection{Konfiguration av I\textsuperscript{2}C-bussen}
https://retrosnob.files.wordpress.com/2013/03/ib-cs-java-enabled.pdf 

Vid användning av ATMega16 tillsammans med en I\textsuperscript{2}C-buss är det inte möjligt att använda parallella bussar, då processorn enbart har en uppsättning utgångar för att hantera I\textsuperscript{2}C. För att lösa detta kan alla enheter kopplas på samma buss och konfigureras på olika sätt. Det sätt som passar bäst beror både av behovet av timing och vilket beroende varje enhet har av data från andra. Nedan listas tre sätt:

\begin{enumerate}
 \item Flera enheter kan konfigureras så att de innehar en master roll. Dessa kan då, när bussen är fri, initiera kontakt med vilken annan enhet den önskar. På så vis kan de i stor utsträckning styra själva när de vill skicka respektive ta emot data.
 
 \item En eller flera slavenheter kan kopplas till den enda masterenheten med avbrott. När slaven vill ha kontakt över I\textsuperscript{2}C-bussen triggar den avbrottssignalen, vilket i sin tur får masterenheten att initiera kontakten. Detta medför att data enbart kan gå mellan masterenheten och respektive slav, inte slavarna emellan.
 
 \item Bussens enda masterenhet pollar slavenheterna med ett jämt intervall. Då kan masterenheten själv styra när den vill ha data, med risk för att slavenheten inte har något att skicka och antingen sätter mastern i vänteläge eller skickar den vidare.
\end{enumerate}

%http://www.nxp.com/documents/user_manual/UM10204.pdf
%https://docs.isy.liu.se/pub/VanHeden/DataSheets/i2cspec2000.pdf

Start condition på I\textsuperscript{2}C-bussen fungerar som ett avbrott, vilket gör att enheterna kopplade till bussen inte behöver ligga och lyssna efter en startsignal. De blir istället avbrutna i det de håller på med.

%https://retrosnob.files.wordpress.com/2013/03/ib-cs-java-enabled.pdf s. 350 (357 i filen)

Avbrottsstyrning håller CPU:n fri då enheten slipper ligga och lyssna efter en signal om att skicka eller ta emot data. Det ligger på varje del i systemet att tillkalla uppmärksamhet. Detta är fördelaktigt då det är kritiskt att något tas om hand precis då det sker.

I polling är det upp till CPU:n (huvudmodulen) att se till att tillfredsställa alla delar i systemet. Fördelen med detta är att den styrande enheten säger till när den har möjlighet att processa en förfrågan.

\subsection{Gränssnittsdesign}

\subsection{Assembler eller C}

Det finns både fördelar och nackdelar med båda programmeringsspråken. De är båda hårdvarunära språk. C tar som nämnt ovan ofta större minnesutrymme när koden exekveras(?). Detta ses dock inte som något problem då ATmega16 anses ha gott om extra minne.
I projektet som ska genomföras har medlemmarna erfarenhet av Assembler programmering.

\subsection{Design av tester}
 
\pagebreak

\section{Resultat och slutsatser}

\subsection{Konfiguration av I\textsuperscript{2}C-bussen}

\subsection{Gränssnittsdesign}

\subsection{Assembler eller C}

\subsection{Design av tester}

\pagebreak
\addcontentsline{toc}{section}{Referenser}
\bibliographystyle{ieeetr}
\bibliography{references}

\pagebreak
\appendix
\section{First Appendix}

\end{flushleft}
\end{document}
